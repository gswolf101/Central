<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Esquiva</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
        }
        canvas {
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1000" height="1000"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Configurações do jogo
        const boundary = {
            x: 50,
            y: 50,
            width: canvas.width - 100,
            height: canvas.height - 100
        };

        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            speed: 5,
            immune: false,
            immuneTime: 0,
            immuneDuration: 1500 // 1.5 segundos
        };

        let bars = [];
        let score = 0;
        let gameOver = false;

        // Controles (adicionando WASD)
        let keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            'w': false,
            'W': false,
            's': false,
            'S': false,
            'a': false,
            'A': false,
            'd': false,
            'D': false,
            ' ': false,
            'Enter': false
        };

        document.addEventListener('keydown', (e) => {
            if (e.key in keys) {
                keys[e.key] = true;
                if (e.key === ' ' && !player.immune) {
                    player.immune = true;
                    player.immuneTime = Date.now();
                }
                if (e.key === 'Enter' && gameOver) {
                    // Reiniciar o jogo
                    player.x = canvas.width / 2;
                    player.y = canvas.height / 2;
                    player.immune = false;
                    bars = [];
                    score = 0;
                    gameOver = false;
                    lastTime = 0;
                    lastFrame = 0;
                    requestAnimationFrame(gameLoop);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key in keys) {
                keys[e.key] = false;
            }
        });

        // Função para verificar se uma nova barra se sobrepõe a barras existentes
        function isBarOverlapping(newBar) {
            return bars.some(bar =>
                newBar.x < bar.x + bar.width &&
                newBar.x + newBar.width > bar.x &&
                newBar.y < bar.y + bar.height &&
                newBar.y + newBar.height > bar.y
            );
        }

        // Função para criar barras
        function createBar() {
            const side = Math.floor(Math.random() * 4); // 0: cima, 1: direita, 2: baixo, 3: esquerda
            let bar = { speed: 3 + Math.floor(score / 10) * 0.5 }; // Aumenta velocidade a cada 10 pontos

            if (side === 0) { // Cima (horizontal)
                bar.width = 60;
                bar.height = 20;
                bar.x = Math.random() > 0.5 ? boundary.x : boundary.x + boundary.width - bar.width;
                bar.y = boundary.y;
                bar.speedX = 0;
                bar.speedY = bar.speed;
            } else if (side === 1) { // Direita (vertical)
                bar.width = 20;
                bar.height = 60;
                bar.x = boundary.x + boundary.width - bar.width;
                bar.y = Math.random() > 0.5 ? boundary.y : boundary.y + boundary.height - bar.height;
                bar.speedX = -bar.speed;
                bar.speedY = 0;
            } else if (side === 2) { // Baixo (horizontal)
                bar.width = 60;
                bar.height = 20;
                bar.x = Math.random() > 0.5 ? boundary.x : boundary.x + boundary.width - bar.width;
                bar.y = boundary.y + boundary.height - bar.height;
                bar.speedX = 0;
                bar.speedY = -bar.speed;
            } else { // Esquerda (vertical)
                bar.width = 20;
                bar.height = 60;
                bar.x = boundary.x;
                bar.y = Math.random() > 0.5 ? boundary.y : boundary.y + boundary.height - bar.height;
                bar.speedX = bar.speed;
                bar.speedY = 0;
            }

            // Verificar sobreposição antes de adicionar
            if (!isBarOverlapping(bar)) {
                bars.push(bar);
            }
        }

        // Função para mover o jogador
        function movePlayer(deltaTime) {
            let newX = player.x;
            let newY = player.y;

            if (keys.ArrowUp || keys.w || keys.W) newY -= player.speed * deltaTime;
            if (keys.ArrowDown || keys.s || keys.S) newY += player.speed * deltaTime;
            if (keys.ArrowLeft || keys.a || keys.A) newX -= player.speed * deltaTime;
            if (keys.ArrowRight || keys.d || keys.D) newX += player.speed * deltaTime;

            // Manter o jogador dentro do limite
            if (newX - player.radius >= boundary.x &&
                newX + player.radius <= boundary.x + boundary.width &&
                newY - player.radius >= boundary.y &&
                newY + player.radius <= boundary.y + boundary.height) {
                player.x = newX;
                player.y = newY;
            }
        }

        // Função para mover barras
        function moveBars(deltaTime) {
            bars.forEach(bar => {
                bar.x += bar.speedX * deltaTime;
                bar.y += bar.speedY * deltaTime;
            });

            // Remover barras que saem da tela
            bars = bars.filter(bar =>
                bar.x + bar.width > boundary.x &&
                bar.x < boundary.x + boundary.width &&
                bar.y + bar.height > boundary.y &&
                bar.y < boundary.y + boundary.height
            );
        }

        // Função para verificar colisão círculo-retângulo
        function checkCircleRectCollision(circle, rect) {
            const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
            const distanceX = circle.x - closestX;
            const distanceY = circle.y - closestY;
            return (distanceX ** 2 + distanceY ** 2) < (circle.radius ** 2);
        }

        // Função para verificar colisões
        function checkCollisions() {
            if (player.immune) return;

            bars.forEach(bar => {
                if (checkCircleRectCollision(player, bar)) {
                    gameOver = true;
                }
            });
        }

        // Função para gerenciar imunidade
        function manageImmunity() {
            if (player.immune && Date.now() - player.immuneTime > player.immuneDuration) {
                player.immune = false;
            }
        }

        // Função para desenhar
        function draw() {
            // Limpar canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Desenhar limite
            ctx.strokeStyle = 'white';
            ctx.strokeRect(boundary.x, boundary.y, boundary.width, boundary.height);

            // Desenhar jogador
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.immune ? 'yellow' : 'white';
            ctx.fill();
            if (player.immune) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 10, 0, Math.PI * 2);
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            ctx.closePath();

            // Desenhar barras
            ctx.fillStyle = 'red';
            bars.forEach(bar => {
                ctx.fillRect(bar.x, bar.y, bar.width, bar.height);
            });

            // Desenhar pontuação
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.fillText(`Pontuação: ${score}`, 10, 30);

            if (gameOver) {
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.fillText('Game Over', canvas.width / 2 - 100, canvas.height / 2);
                ctx.font = '24px Arial';
                ctx.fillText(`Pontuação Final: ${score}`, canvas.width / 2 - 80, canvas.height / 2 + 40);
                ctx.fillText('Pressione Enter para reiniciar', canvas.width / 2 - 120, canvas.height / 2 + 80);
            }
        }

        // Loop principal do jogo
        let lastTime = 0;
        let lastFrame = 0;
        function gameLoop(timestamp) {
            if (gameOver) return;

            const deltaTime = (timestamp - lastFrame) / 16.67; // Normalizado para 60 FPS
            lastFrame = timestamp;

            const barInterval = 1000 - Math.min(score * 10, 500); // Reduz intervalo até 500ms
            if (timestamp - lastTime > barInterval) {
                createBar();
                lastTime = timestamp;
                score++;
            }

            movePlayer(deltaTime);
            moveBars(deltaTime);
            manageImmunity(); // Chamado antes de checkCollisions
            checkCollisions();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Iniciar o jogo
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
